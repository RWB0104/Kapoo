---
title: "스택과 큐로 간결한 코드 생성"
excerpt: ""
coverImage: "https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png"
date: "2021-07-29T04:54:40"
type: "posts"
category: "알고리즘"
tag: [ "자료구조", "알고리즘", "누구나 자료 구조와 알고리즘", "해시 테이블" ]
group: "누구나 자료 구조와 알고리즘"
comment: true
publish: true
---

<p class="orange-A400" align="center">본 포스팅은 개인 스터디 모임 활동의 일환으로, "누구나 자료구조와 알고리즘" 도서를 정독한 뒤 해당 내용을 정리한 포스팅입니다.</p>

# 8장 스택과 큐로 간결한 코드 생성

이 장에서는 <span class="amber-400">스택</span>과 <span class="amber-400">큐</span>에 대해 알아본다. 사실 이 두 자료구조는 배열에 특정한 제약을 건 자료구조다. <span class="red-400">제약</span>이라는 개념 때문에 특수한 상황에서만 쓰이지 않을까 싶지만, 오히려 이러한 제약이 주는 규칙으로 인해 굉장히 많은 곳에서 쓰인다.

스택과 큐의 가장 큰 특징은 <span class="green-400">데이터 처리에 순서</span>가 있다는 점이다. 스택과 큐는 그 제약에 따라 반드시 정해진 순서로 데이터를 처리한다. 이러한 특징 덕에 순서가 필요한 작업들에 유용하게 사용된다. 대표적으로 스케쥴러, 대기 등이 있으며 OS의 인터럽트(Interrupt) 작업에서 스택이 쓰인다.

## 8-1. 스택

<span class="amber-400">스택</span>이 데이터를 관리하는 방식은 배열의 그것과 매우 유사하다. 아까도 말했듯이, 스택과 큐엔 특정한 제약이 걸려있으며 그 중 스택의 제약은 아래와 같다.

* 데이터는 반드시 스택의 입구에서만 삽입할 수 있다.
* 스택의 가장 끝에 위치한 데이터만 읽을 수 있다.
* 스택의 가장 끝에 위치한 데이터만 삭제할 수 있다.

스택의 입구는 하나 뿐이며, 이 <span class="red-400">입구에서 모든 연산</span>이 일어난다. 길쭉한 프링글스 통을 연상하면 이해하기 쉽다. 프링글스 칩을 꺼내먹기 위해선 반드시 정해진 입구에서만 꺼내서 먹을 수 있으며, 맨 위의 칩만 꺼낼 수 있다. 스택의 데이터와 연산을 이에 대입하면 매우 유사하다.

스택의 입구. 즉, 끝을 위(top)이라 하며, 스택의 가장 밑을 아래(bottom)라 한다. 스택의 연산은 두 가지로 나뉜다.

| 구분  |     내용      |
| :---: | :-----------: |
| PUSH  | 데이터를 삽입 |
|  POP  | 데이터를 삭제 |

스택의 푸시 연산을 도식화하면 아래와 같다.

1. 스택에 2를 푸시한다.

<img src="https://user-images.githubusercontent.com/50317129/127523633-6a838ba9-339f-4443-bfd7-bea18c4d6558.png" width="200px" />

2. 스택에 6을 푸시한다.

<img src="https://user-images.githubusercontent.com/50317129/127523640-caec6583-e44a-43f8-95d0-678f1aac1523.png" width="200px" />

3. 스택에 9를 푸시한다.

<img src="https://user-images.githubusercontent.com/50317129/127523649-7046261f-d896-4c24-bd68-648a795c8b58.png" width="200px" />

푸시는 항상 스택의 위에서 이루어진다는 점을 기억하자.

스택의 팝 연산은 아래와 같다.

1. 스택에 9를 팝한다.

<img src="https://user-images.githubusercontent.com/50317129/127523655-40e026a8-5631-41c8-a300-03d0ce237242.png" width="200px" />

2. 스택에 6을 팝한다.

<img src="https://user-images.githubusercontent.com/50317129/127523665-e28389b1-27d0-4fb9-b29a-aa4c5278c253.png" width="200px" />

이 과정 후엔 스택에 5만 남게된다. 스택은 항상 위에만 데이터를 삽입할 수 있으므로, 스택의 중간에 데이터를 삽입하려면 해당 위치까지 모든 데이터를 팝한 뒤 푸시해야한다.

이렇게 먼저 들어온 게 가장 늦게 나가고. 반대로 가장 늦게 들어온 게 가장 빨리 나가는 걸 <span class="primary">LIFO</span>(Last In, First Out)이라 한다.

월요일의 출근길을 생각해보자. 최대한 늦게 들어가고 최대한 빨리 나오고 싶지 않은가?

## 8-2. 스택 다뤄보기

필자는 코드 규칙에 굉장히 민감한 편이다. 쓸데없이 예민해서, 내 방식대로 포맷팅이 되어있지 않은 소스는 리딩만으로도 스트레스를 받는다. 굳이 내 방식이 아니더라도 일관성있는 규칙이라면 그나마 나은데, 일관성도 없이 막 짠 코드를 보는 건 정말이지.... 가뜩이나 코드 리딩도 제대로 못 하는데 코드가 난잡하기까지 하면 당연히 답이 없을 것 같다.

그래서 나는 ESLint를 굉장히 선호한다. TypeScript, HTML 등의 코드를 내가 정의한 규칙에 부합한지 알려주고, 틀리다면 수정까지 해준다. 나같이 코드 규칙에 예민한 사람에겐 필수품이나 다름없다.

이렇게 코드를 정렬해주는 Lint는 언어별로 다른 규칙을 일일히 이해하고 틀린 부분을 잘 찾아야 하므로 딱 봐도 구현하기 매우 어려워 보인다. 이 문단에서는 스택을 활용하여 간단한 코드 Lint를 만들어본다.

예를 들어, 아래와 같은 코드가 있다고 가정하자.

``` javascript
// 정상
const list = [ 1, 2, 3 ]

// 오류. 닫는 대괄호 없음
const list = [ 1, 2, 3

// 오류. 여는 대괄호 없음
const list = 1, 2, 3]
```

