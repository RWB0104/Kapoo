---
title: "[OOP] 캡슐화(Encapsulation)와 정보 은닉"
excerpt: ""
coverImage: "https://user-images.githubusercontent.com/50317129/128211434-7c28e08b-c867-4b08-98c0-bcf94f0e54b3.png"
date: "2021-08-08T11:05:05"
type: "posts"
category: "CS"
tag: [ "CS", "객체지향", "캡슐화", "정보 은닉", "접근제어자" ]
group: "객체지향"
comment: true
publish: false
---

## 리스코프 치환 원칙 (Liskov Substitution Principle)

<span class="red-600">자식 객체는 부모 객체를 대체</span>할 수 있다는 원칙이다.

예를 들어, 자동차 객체를 부모로 하는 소형차 객체가 있다고 가정하자. 객체지향을 잘 지켜 구현했다면 소형차는 부모 객체인 자동차의 특성을 모두 포함한다.

소형차가 자동차의 특징을 모두 포함하고 있으므로, 자동차를 완전히 대체할 수 있다.

## 인터페이스 분리 원칙 (Interface Segregation Principle)

<span class="red-600">클라이언트 자신이 사용하지 않는 메소드에 의존성을 가지면 안된다</span>는 원칙이다.

만약 인터페이스의 규모나 동작이 너무 광범위할 경우 각각의 작은 단위로 분리하여 클라이언트가 필요한 인터페이스만을 사용하도록 한다.

![image](https://user-images.githubusercontent.com/50317129/128585790-a761f795-b4da-4a52-865d-d2dd4b858f20.png)

예를 들어, 스마트폰이라는 객체가 있다고 가정하자. 이 스마트폰 객체는 비교적 최신에 나온 덕분에 일반적인 스마트폰 기능 외에도 무선 충전, AR 뷰어, 생체인식 등의 다채로운 기능을 포함하고 있다.

이를 가지고 S20을 구현하면 스마트폰 객체의 동작 모두가 필요하므로 ISP를 만족한다. 그러나 S2를 구현할 경우, 무선 충전, 생체인식과 같은 기능을 제공하지 않는다. 그럼에도 불구하고 부모 객체인 스마트폰에 이러한 인터페이스가 포함되어 있으므로, S2 입장에서는 필요하지도 않은 기능을 구현해야하는 낭비가 발생한다.

때문에 스마트폰 객체의 기능을 각각의 인터페이스로 분리하여 필요한 모듈만을 연결하면 S20, S2 모두 필요한 인터페이스만을 상속받아 구현할 수 있게 된다.

## 의존성 역전 원칙 (Dependency Inversion Principle)

<span class="red-600">클라이언특 자신이 사용하지 않는 메소드에 의존성을 가지면 안된다</span>