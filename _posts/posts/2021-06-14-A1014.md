---
title: "[백준 / JAVA] 백준 알고리즘 1014번 컨닝"
excerpt: ""
coverImage: "https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png"
date: "2021-06-14T01:56:01"
type: "posts"
category: "알고리즘"
tag: [ "백준", "알고리즘", "JAVA(자바)", "PLATINUM", "PLATINUM IV" ]
group: "백준 알고리즘"
comment: true
publish: true
---

# Contact

![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)

🔗 [전체 1014번 문제](https://www.acmicpc.net/problem/1014)

## 조건

| 시간제한 | 메모리 제한 |
| :------: | :---------: |
|   2초    |    512MB    |

## 문제

최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.

시험은 $N$행 $\times$ $M$열 크기의 직사각형 교실에서 이루어진다. 교실은 $1 \times 1$ 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.

최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.

<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/122051353-78bea480-ce1f-11eb-92c3-5fa4e3dc96b9.png" width="500px" />
</p>

위의 그림을 보자. $A$, $C$, $D$ 혹은 $E$에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, $B$에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.

위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.

최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.

## 입력

입력의 첫 줄에는 테스트케이스의 개수 $C$가 주어진다. 각각의 테스트 케이스는 아래와 같이 두 부분으로 이루어진다.

첫 번째 부분에서는 교실의 세로길이 N과 가로길이 M이 한 줄에 주어진다. $(1 ≤ M ≤ 10, 1 ≤ N ≤ 10)$

두 번째 부분에서는 정확하게 N줄이 주어진다. 그리고 각 줄은 M개의 문자로 이루어져있다. 모든 문자는 ‘.’(앉을 수 있는 자리) 또는 ‘x’(앉을 수 없는 자리, 소문자)로 구성된다.

## 출력

각각의 테스트 케이스에 대해 그 교실에서 시험을 볼 수 있는 최대 학생의 수를 출력한다.

## 케이스

### 예제 1

+ 입력

``` tc
4
2 3
...
...
2 3
x.x
xxx
2 3
x.x
x.x
10 10
....x.....
..........
..........
..x.......
..........
x...x.x...
.........x
...x......
........x.
.x...x....
```

+ 출력

``` tc
4
1
2
46
```

# 풀이

또 한번의 <span class="teal-A400">플래티넘</span> 문제. 하....

문제 이름 그대로 컨닝을 못 참게 만드는 문제다. 문제를 푸는 방식에는 두 가지가 있다. <span class="primary">네트워크 플로우</span>와 <span class="primary">비트마스킹</span>. 나 같이 전공지식이 전무한 코더에게는 너무나도 가혹한 문제다. 지금까지 살면서 하나 깨달은 게 있다면, 아무리 처음 보는 개념이라도 계속 쳐다보면 언젠가 이해된다. 하루가 됐든 한 달이 됐든. 그 난리를 펴가며 이해한 내용은 아래와 같다.

## 문제 분석하기

문제 해결에 영향을 미치는 조건은 아래와 같다.

1. 임의의 자리를 기준으로 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위 자리를 컨닝할 수 있다.
2. 파손되어 앉을 수 없는 자리가 존재한다.

임의의 자리가 있다고 가정하고 이를 도식화해보자.

-- 사진 1 --

위 사진과 같이 <span class="indigo-A400">특정 자리</span>를 기준으로 자신의 주변엔 최대 8개의 <span class="indigo-200">자리</span>가 존재할 수 있다. 1번 규칙에 따라 컨닝이 가능한 자리를 도식하면 아래와 같다.

-- 사진 2 --

<span class="red-400">컨닝 가능한 자리</span>는 위와 같이 6개로 표시된다. 엥? 분명히 1번 규칙에서는 <span class="indigo-A400">특정 자리</span>를 기준으로 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위만 가능하다고 했다. 해당 규칙에 따르면 4개 자리여야 할텐데, 왼쪽 대각선 아래, 오른쪽 대각선 아래는 왜 해당되는걸까?

<span class="indigo-A400">특정 자리</span>에서 왼쪽 대각선 아래, 오른쪽 대각선 아래를 컨닝할 순 없지만, 반대로 왼쪽 대각선 아래, 오른쪽 대각선 아래에선 <span class="indigo-A400">특정 자리</span>를 컨닝할 수 있기 때문. <span class="lightBlue-A400">컨닝을 할 수 있는 자리와 당할 수 있는 자리</span> 모두를 고려해야한다.

반대로 컨닝이 불가능한 자리를 도식하면 아래와 같다.

-- 사진 3 --

<span class="green-A400">컨닝이 불가능한 자리</span>는 위와 같이 2개로 표시된다. 자신의 앞 뒤는 컨닝할 수 없다. 우리가 설계한 알고리즘이 이와 같은 결과를 계산할 수 있어야 한다. 그렇다면 이를 어떤 방법으로 해결할 수 있을까?

이 문제를 해결하는 방법은 크게 두 가지가 있다.

1. 최소 버텍스 커버, 이분 매칭
2. DP, 비트마스킹

이 중 1번 최소 버텍스 커버와 이분 매칭을 사용하여 풀고자 한다.

## Miminum Vertex Cover(최소 버텍스 커버)

<span class="primary">Miminum Vertex Cover(최소 버텍스 커버)</span>는 모든 노드가 연결된 점(Vertex)의 최소 집합을 의미한다. 예를 들어, 아래와 같은 그림이 있다고 가정하자.

-- 사진 4 --

위 사진에서의 $A$ ~ $I$에 해당하는 9개 점이 Vertex, 각 점마다 연결된 선이 노드가 된다. 버텍스가 모든 노드를 커버할 수 있다면 <span class="primary">버텍스 커버</span>라 볼 수 있다. 그 중 <span class="green-A400">모든 노드를 커버하는 가작 적은 버텍스의 집합</span>이 <span class="primary">Miminum Vertex Cover(최소 버텍스 커버)</span>라 할 수 있다.

-- 사진 5 --

버텍스 $E$의 경우, 대다수의 노드를 포함하고 있지만 $\overline{AB}$, $\overline{BC}$, $\overline{FI}$ 노드를 포함하지 않으므로 버텍스 $E$만으로는 <span class="primary">최소 버텍스 커버</span> 조합이 될 수 없다.

-- 사진 6 --

위와 같이 $B$, $F$ 버텍스를 포함할 경우 존재하는 모든 노드를 포함하는 가장 적은 버텍스의 조합이므로 <span class="primary">최소 버텍스 커버</span>가 된다.

유의깊게 봐야할 점은, <span class="primary">최소 버텍스 커버</span>를 통해 <span class="primary">최대 독립 집합</span>을 구할 수 있다. <span class="primary">최소 버텍스 커버</span>에 해당하는 버텍스와 모든 노드를 제거해보자. 아래와 같이 도식할 수 있다.

-- 사진 7 --

이처럼, 전체 그룹에서 <span class="primary">최소 버텍스 커버</span>를 제거하면 <span class="orange-A400">나머지 버텍스들은 그 어떤 버텍스끼리도 연결되지 않는 독립 버텍스</span>다. <span class="primary">최소 버텍스 커버</span>가 모든 노드를 연결한 버텍스의 최소 집함임을 생각한다면, 이를 뺀 나머지는 어떤 버텍스와도 연결되지 않는 버텍스 집합의 최대 조합이라고 할 수 있다. 즉, 최대 독립 집합 $=$ 전체 그룹 $-$ 최소 버텍스 커버로 표현할 수 있다.

그래, 그건 그렇다 치고, 위 개념이 이 문제와 무슨 연관성이 있길래 이렇게 장황하게 서술할까? 이번엔 조금 다르게 이 문제와 연관지어 예시를 들어본다.

-- 사진 8 --

그 어떤 자리도 파손되지 않은 온전한 9개 자리가 있다고 가정하자. 각 자리별로 컨닝이 가능한 자리를 노드로 연결하면 위와 같이 도식할 수 있다.

-- 사진 9 --

위 사진에서 <span class="primary">최소 버텍스 커버</span>는 $B$, $E$, $H$가 된다. 이 자리 3개로 위 사진의 모든 노드를 포함할 수 있기 때문이다. 이 자리들을 제거하여 <span class="primary">최대 독립 집합</span>을 표현하면 어떻게 될까?

-- 사진 10 --

나머지 자리인 $A$, $C$, $D$, $F$, $G$, $H$만 남게 되며, 각 자리는 그 어떤 노드와도 연결되어있지 않다. 이 사진에서의 노드는 컨닝 가능한 자리이므로, **노드가 없다는 것은 컨닝할 수 있는 자리가 없다**는 뜻이 된다. 즉, <span class="primary">최소 버텍스 커버</span> 로직을 설계하는 것이 이번 알고리즘의 키 포인트다.

## 이분 매칭

자, <span class="primary">최소 버텍스 커버</span>가 알고리즘의 키인 건 알았으니, 이를 구현하기만 하면 된다. 안타깝게도 <span class="primary">최소 버텍스 커버</span>를 코딩으로 계산하는 것은 매우 복잡한 일이다.

그러나 ****

## 전체 소스

``` java

```

## 분류

* 다이나믹 프로그래밍
* 비트마스킹
* 최대 유량
* 비트필드를 이용한 다이나믹 프로그래밍