---
title: "[JAVA] 백준 알고리즘 1007번 벡터"
excerpt: ""
coverImage: "https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png"
date: "2021-06-09T00:50:26"
type: "posts"
category: "알고리즘"
tag: [ "백준", "알고리즘", "JAVA(자바)", "Brute Force(무차별 대입 공격)", "Combination(조합)", "BackTracking(백트래킹)", "GOLD", "GOLD II" ]
group: "백준 알고리즘"
comment: true
publish: true
---

# 습격자 초라기

![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)

🔗 [전체 1007번 문제](https://www.acmicpc.net/problem/1007)

# 조건

| 시간제한 | 메모리 제한 |
| :------: | :---------: |
|   2초    |    512MB    |

## 문제

평면 상에 $N$개의 점이 찍혀있고, 그 점을 집합 $P$라고 하자. 집합 $P$의 벡터 매칭은 벡터의 집합인데, 모든 벡터는 집합 $P$의 한 점에서 시작해서, 또 다른 점에서 끝나는 벡터의 집합이다. 또, $P$에 속하는 모든 점은 한 번씩 쓰여야 한다.

$V$에 있는 벡터의 갯수는 $P$에 있는 점의 절반이다.

평면 상의 점이 주어졌을 때, 집합 $P$의 벡터 매칭에 있는 벡터의 합의 길이의 최솟값을 출력하는 프로그램을 작성하시오.

## 입력

첫째 줄에 테스트 케이스의 개수 $T$가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.

테스트 케이스의 첫째 줄에 점의 갯수 $N$이 주어진다. $N$은 짝수이다. 둘째 줄부터 $N$개의 줄에 점의 좌표가 주어진다. $N$은 20보다 작거나 같은 자연수이고, 좌표는 절댓값이 100,000보다 작거나 같은 정수다. 모든 점은 서로 다르다.

## 출력

각 테스트 케이스마다 정답을 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.

## 케이스

### 예제 1

+ 입력

``` tc
2
4
5 5
5 -5
-5 5
-5 -5
2
-100000 -100000
100000 100000
```

+ 출력

``` tc
0.000000000000
282842.712474619038
```

# 풀이

두 개의 점으로 하나의 벡터를 만들 수 있다. $N <= 20$이므로 주어지는 점의 최대 갯수는 20개다. $N = 20$이라고 가정하면, 만들 수 있는 벡터의 수는 그 절반인 10개다. 20개의 점을 어떻게 잇느냐에 따라서 벡터 10개를 만드는 수 많은 경우의 수가 발생한다. 이 경우의 수에서 <span class="red-A400">벡터의 총합이 가장 작은 값을 계산</span>하는 게 이 알고리즘의 결과다.(10개의 벡터 중 가장 짧은 벡터를 계산하는 것이 아님에 유의하자.)

이 알고리즘의 핵심은 <span class="green-A400">$N$개의 원소에서 $N / 2$개의 벡터를 만들 수 있는 경우를 계산해서 최소값을 계산</span>하면 된다. $N$의 최대값이 20으로 매우 작으므로 하나하나 비교하는 것이 가능하다. 애초에 알고리즘 자체가 Brute Force(무차별 대입 공격)으로 분류돼있기도 하고.

그렇다고 10개의 벡터를 for문 돌려가며 하나하나 만드는 방법은 안 된다. 좀 더 효율적으로 벡터를 계산하는 방법을 생각해보자. 예제 1을 통해 원리를 생각해보자. 해당 예제에서는 총 4개의 점이 주어진다.

* $(5, 5)$
* $(5, -5)$
* $(-5, 5)$
* $(-5, -5)$

정사각형 형태의 좌표다. 점의 갯수가 4개이므로 2개의 벡터를 만들 수 있다. 총 원소 중 몇 개의 원소를 선택해

## 전체 소스

``` java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * 백준 전체 1007 문제 알고리즘 클래스
 *
 * @author RWB
 * @see <a href="https://rwb0104.github.io/posts/2021/06/07/A1007/">1007 풀이</a>
 * @since 2021.06.09 Tue 00:50:26
 */
public class Main
{
	private static double result;
	
	private static boolean[] isChecked;
	
	private static int[][] P;
	
	/**
	 * 메인 함수
	 *
	 * @param args: [String[]] 매개변수
	 *
	 * @throws IOException 데이터 입출력 예외
	 */
	public static void main(String[] args) throws IOException
	{
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		
		// 케이스 수
		int T = Integer.parseInt(reader.readLine());
		
		for (int i = 0; i < T; i++)
		{
			// 점의 갯수
			int N = Integer.parseInt(reader.readLine());
			
			result = Double.MAX_VALUE;
			
			isChecked = new boolean[N];
			
			P = new int[N][2];
			
			for (int j = 0; j < N; j++)
			{
				String[] temp = reader.readLine().split(" ");
				
				P[j][0] = Integer.parseInt(temp[0]);
				P[j][1] = Integer.parseInt(temp[1]);
			}
			
			combination(0, N / 2);
			
			System.out.println(result);
		}
		
		reader.close();
	}
	
	/**
	 * 조합 함수
	 *
	 * @param index: 인덱스
	 * @param count: 조합할 원소 갯수
	 */
	private static void combination(int index, int count)
	{
		// 조합할 원소 갯수가 더 이상 없을 경우
		if (count == 0)
		{
			result = Math.min(result, getVector());
		}
		
		// 조합할 원소 갯수가 아직 남아있을 경우
		else
		{
			for (int i = index; i < P.length; i++)
			{
				isChecked[i] = true;
				
				combination(i + 1, count - 1);
				
				isChecked[i] = false;
			}
		}
	}
	
	/**
	 * 벡터 계산 함수
	 *
	 * @return {double} 벡터 크기
	 */
	private static double getVector()
	{
		int x = 0;
		int y = 0;
		
		for (int i = 0; i < P.length; i++)
		{
			// 양수로 선택된 점일 경우
			if (isChecked[i])
			{
				x += P[i][0];
				y += P[i][1];
			}
			
			// 음수로 선택된 점일 경우
			else
			{
				x -= P[i][0];
				y -= P[i][1];
			}
		}
		
		return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
	}
}
```