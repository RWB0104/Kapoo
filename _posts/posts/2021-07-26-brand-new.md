---
title: "블로그 개편기"
excerpt: ""
coverImage: "https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png"
date: "2021-07-26T04:54:40"
type: "posts"
category: "React"
tag: [ "React(리액트)", "Next.js", "개발 블로그", "TypeScript", "SCSS" ]
comment: true
publish: false
---

# 리모델링

이 블로그를 처음 개발한지가 한 5월 쯤으로 기억한다. 4월부터 접한 리액트에 흥미가 생겨 두서없이 만든게 시작이였으니, 결과물은 내 생각보다 훨씬 조잡하지 않았나 생각했다.

다행스럽게(?)도 블로그 또한 그런 내 믿음을 져버리기 싫었는지, 동작 과정에서 크고 작은 문제들을 보여주곤 했다.

동작 자체에 영향을 미칠 정도로 크리티컬한 문제는 아니였다만, 내 신경엔 영향을 미칠 정도로 거슬리는 부분이 몇 가지 있었다. 아무도 관심 없지만 이왕 만든거 이번 포스팅을 통해 블로그의 개선점을 정리해놓고자 한다.

# 문제점

크고작은 여러 문제점들이 있었는데, 목록은 아래와 같다.

## 1. 렌더링 지연 현상

여러 문제들 중 가장 가시적이고 불편한 문제였다. 어떠한 이유에서인지 이상하리만치 렌더링이 늦었다. 처음으로 페이지에 접근할 경우 렌더링하느라 버벅이는게 보일 정도. 사양에 따라서 CSS가 입혀지기 전인 날 것의 HTML 프레임이 그대로 보이기도 했다.

이 괴상한 렌더링 지연은 React의 고질적인 블랙박스 문제로 디버깅조차 잘 되지 않았다.

> **블랙... 뭔 박스요?**  
> 소스코드가 동작할 때, 어떤 특정한 모듈을 통해 동작하는 경우가 빈번하다. 잘 구성된 모듈은 은닉화, 모듈화가 잘 되어 있는 경우가 대부분이다. 하지만 이러한 모듈의 폐쇄성은 해당 모듈의 사용자로 하여금 모듈 내부의 오류로 인해 발생하는 이슈를 디버깅하기 매우 어렵게 만든다.  
> 이러한 모듈의 은닉된 영역을 가리켜 **블랙박스**라 칭한다.

간혹 어떤 페이지는 렌더링이 두 번씩 되기도 했다. 설상가상으로 React의 다중 렌더링 문제는 꽤 고질적이라고 한다.

## 2. Unified.js과 관련 플러그인 커스터마이징 문제

해당 블로그는 JAMStack 기반 블로그다. 통상 JAMStack 기반 블로그의 경우 게시글을 Markdown으로 관리한다. 하지만 아쉽게도 웹 페이지는 HTML 기반으로 동작한다. 즉, Markdown에서 HTML로 적절히 변환해줄 로직이 필요하다.

> **JAMStack**  
> **J**avaScript  
> **A**PI  
> **M**arkup

단순히 변환만 해준다고 다가 아니다. 코드 하이라이팅을 위한 Prism.js, 수식 작성을 위한 LaTex 등 여러 플러그인을 적용해야한다.

하지만 Unified.js는 내 바램과 달리 공식 문서가 그리 친절하지도 않았으며, 커스터마이징을 위한 API 또한 찾아보기 힘들었다. 그 말인즉슨 `remark-prism`, `remark-toc`와 같은 플러그인에 의존해야 하는데, 정해진 형태로 변환만 해줄 뿐, 내가 끼어들어 커스터마이징할 여지는 없어보였다.

## 3. JS-in-CSS 방식

이 블로그의 CSS는 [Material-UI](https://material-ui.com/)를 적극적으로 사용했다. Material-UI는 CSS를 적용할 때, `makeStyles`와 같은 메소드를 통해 JavaScript 내부에서 스타일링을 하도록 안내하고 있다.

React를 독학으로 배운데다가, 그 체계에 익숙하지 않아 그 당시만 해도 이렇게 해야만하는 줄 알았다.

## 4. 부실한 RESTful URL

NextJS는 Dynamic Routing을 지원한다. 파일 이름을 `[page].js`와 같이 생성하고 `getStaticPaths` 메소드에서 page 변수에 적절한 값을 할당하면 해당 값을 가진 URL을 생성해준다.

GitHub에 호스팅하기 위해선 좋든 싫든 CSR 정적 방식을 차용할 수 밖에 없다. 때문에 내가 잘 하던 기존의 query 방식을 차용했었다.

게시글 2 페이지를 나타내는 URL이 `/posts?page=2`와 같은 방식이였다. 현재 트렌드로 미루어보아, 그리 좋은 방식은 아니지 싶다.

# 개선점

자잘한 문제들은 제외하고, 굵직한 것들만 생각나는대로 적으면 저 정도 나오는 것 같다.

블로그가 개발된 5월 이래로 개편을 시작한 7월 중순까지 그래도 나름 내적인 성장을 했던 건지, 이전보단 훨씬 나은 방향으로 개선할 수 있었다.

개선 내용은 아래와 같다.

## 1. TypeScript 적용

JavaScript의 가장 큰 장점이자 단점은 변수 타입의 모호성이다. 첫 언어를 C#, JAVA와 같이 경직된 객체지향 언어로 접한 내겐 거슬리는 부분 중 하나였다.

<span class="blue-400">TypeScript</span>는 JavaScript에 변수 타입이라는 개념을 도입함으로써, 변수의 모호함에서 유발되는 오류를 최소화한다.

Next.js는 TypeScript 기반의 템플릿을 제공해준다. TypeScript를 전혀 해보진 않았지만, "어치파 JavaScript에 타입 선언만 추가된 거 아닌가?"라는 생각이 들어 적용했다.

TypeScript에 적응하는 데 그리 오랜 시간이 걸리진 않은 걸로 기억한다. 내 생각대로 타입 선언 말곤 크게 달라진 게 없으니. 오히려 타입이 명시되니 해당 변수에 사용할 수 있는 올바른 내부함수라던가, 자동완성이 적용되서 훨씬 쾌적한 개발을 할 수 있었다.

단, 짜증나는 점이 하나 있었는데, 라이브 서버와 컴파일 간의 차이였다. Next.js에서는 작성한 소스코드를 즉시 반영해주는 일종의 라이브 서버를 구동할 수 있는데, <span class="red-400">TypeScript에서 오류가 나는 문장이나 문법이 라이브 서버에선 영향을 미치지 않는다.</span> 즉, 보기에 멀쩡한 코드길래 빌드를 수행하면 그제서야 갖가지 오류를 뱉어낸다.

더 환장하는건, 실제론 동작 자체에 문제가 없는 소스다. JavaScript라면 무사통과할 수 있는 매우 정상적인 소스라는 뜻이다. 하지만 TypeScript는 아무도 막을 수 없어서 조금만 의심스러운 부분이 있다면 바로 찡찡대기 시작한다.

"아니 저거 null일 수도 있다니까요!", "이거 타"

이러한 문제들은 