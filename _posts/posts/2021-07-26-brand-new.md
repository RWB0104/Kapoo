---
title: "블로그 개편기"
excerpt: ""
coverImage: "https://user-images.githubusercontent.com/50317129/125144706-add9c080-e159-11eb-9522-063c655ddf36.png"
date: "2021-07-26T04:54:40"
type: "posts"
category: "React"
tag: [ "React(리액트)", "Next.js", "개발 블로그", "TypeScript", "SCSS" ]
comment: true
publish: false
---

# 리모델링

이 블로그를 처음 개발한지가 한 5월 쯤으로 기억한다. 4월부터 접한 리액트에 흥미가 생겨 두서없이 만든게 시작이였으니, 결과물은 내 생각보다 훨씬 조잡하지 않았나 생각했다.

다행스럽게(?)도 블로그 또한 그런 내 믿음을 져버리기 싫었는지, 동작 과정에서 크고 작은 문제들을 보여주곤 했다.

동작 자체에 영향을 미칠 정도로 크리티컬한 문제는 아니였다만, 내 신경엔 영향을 미칠 정도로 거슬리는 부분이 몇 가지 있었다. 아무도 관심 없지만 이왕 만든거 이번 포스팅을 통해 블로그의 개선점을 정리해놓고자 한다.

# 문제점

크고작은 여러 문제점들이 있었는데, 목록은 아래와 같다.

## 1. 렌더링 지연 현상

여러 문제들 중 가장 가시적이고 불편한 문제였다. 어떠한 이유에서인지 이상하리만치 렌더링이 늦었다. 처음으로 페이지에 접근할 경우 렌더링하느라 버벅이는게 보일 정도. 사양에 따라서 CSS가 입혀지기 전인 날 것의 HTML 프레임이 그대로 보이기도 했다.

이 괴상한 렌더링 지연은 React의 고질적인 블랙박스 문제로 디버깅조차 잘 되지 않았다.

> **블랙... 뭔 박스요?**  
> 소스코드가 동작할 때, 어떤 특정한 모듈을 통해 동작하는 경우가 빈번하다. 잘 구성된 모듈은 은닉화, 모듈화가 잘 되어 있는 경우가 대부분이다. 하지만 이러한 모듈의 폐쇄성은 해당 모듈의 사용자로 하여금 모듈 내부의 오류로 인해 발생하는 이슈를 디버깅하기 매우 어렵게 만든다.  
> 이러한 모듈의 은닉된 영역을 가리켜 **블랙박스**라 칭한다.

간혹 어떤 페이지는 렌더링이 두 번씩 되기도 했다. 설상가상으로 React의 다중 렌더링 문제는 꽤 고질적이라고 한다.

## 2. Unified.js과 관련 플러그인 커스터마이징 문제

해당 블로그는 JAMStack 기반 블로그다. 통상 JAMStack 기반 블로그의 경우 게시글을 Markdown으로 관리한다. 하지만 아쉽게도 웹 페이지는 HTML 기반으로 동작한다. 즉, Markdown에서 HTML로 적절히 변환해줄 로직이 필요하다.

> **JAMStack**  
> **J**avaScript  
> **A**PI  
> **M**arkup

단순히 변환만 해준다고 다가 아니다. 코드 하이라이팅을 위한 Prism.js, 수식 작성을 위한 LaTex 등 여러 플러그인을 적용해야한다.

하지만 Unified.js는 내 바램과 달리 공식 문서가 그리 친절하지도 않았으며, 커스터마이징을 위한 API 또한 찾아보기 힘들었다. 그 말인즉슨 `remark-prism`, `remark-toc`와 같은 플러그인에 의존해야 하는데, 정해진 형태로 변환만 해줄 뿐, 내가 끼어들어 커스터마이징할 여지는 없어보였다.

## 3. CSS-in-JS 방식

이 블로그의 CSS는 [Material-UI](https://material-ui.com/)를 적극적으로 사용했다. Material-UI는 CSS를 적용할 때, `makeStyles`와 같은 메소드를 통해 JavaScript 내부에서 스타일링을 하도록 안내하고 있다.

React를 독학으로 배운데다가, 그 체계에 익숙하지 않아 그 당시만 해도 이렇게 해야만하는 줄 알았다.

## 4. 부실한 RESTful URL

NextJS는 Dynamic Routing을 지원한다. 파일 이름을 `[page].js`와 같이 생성하고 `getStaticPaths` 메소드에서 page 변수에 적절한 값을 할당하면 해당 값을 가진 URL을 생성해준다.

GitHub에 호스팅하기 위해선 좋든 싫든 CSR 정적 방식을 차용할 수 밖에 없다. 때문에 내가 잘 하던 기존의 query 방식을 차용했었다.

게시글 2 페이지를 나타내는 URL이 `/posts?page=2`와 같은 방식이였다. 현재 트렌드로 미루어보아, 그리 좋은 방식은 아니지 싶다.

# 개선점

자잘한 문제들은 제외하고, 굵직한 것들만 생각나는대로 적으면 저 정도 나오는 것 같다.

블로그가 개발된 5월 이래로 개편을 시작한 7월 중순까지 그래도 나름 내적인 성장을 했던 건지, 이전보단 훨씬 나은 방향으로 개선할 수 있었다.

개선 내용은 아래와 같다.

## 1. TypeScript 적용

JavaScript의 가장 큰 장점이자 단점은 변수 타입의 모호성이다. 첫 언어를 C#, JAVA와 같이 경직된 객체지향 언어로 접한 내겐 거슬리는 부분 중 하나였다.

<span class="blue-400">TypeScript</span>는 JavaScript에 변수 타입이라는 개념을 도입함으로써, 변수의 모호함에서 유발되는 오류를 최소화한다.

Next.js는 TypeScript 기반의 템플릿을 제공해준다. TypeScript를 전혀 해보진 않았지만, "어차피 JavaScript에 타입 선언만 추가된 거 아닌가?"라는 생각이 들어 적용했다.

TypeScript에 적응하는 데 그리 오랜 시간이 걸리진 않은 걸로 기억한다. 내 생각대로 타입 선언 말곤 크게 달라진 게 없으니. 오히려 타입이 명시되니 해당 변수에 사용할 수 있는 올바른 내부함수라던가, 자동완성이 적용되서 훨씬 쾌적한 개발을 할 수 있었다.

단, 짜증나는 점이 하나 있었는데, 바로 라이브 서버와 컴파일 간의 차이였다. Next.js에서는 작성한 소스코드를 즉시 반영해주는 일종의 라이브 서버를 구동할 수 있다. 여기서 좀 짜증나는 차이가 발생하는데, <span class="red-400">TypeScript에서 오류가 나는 문장이나 문법이 라이브 서버에선 영향을 미치지 않는다.</span> 즉, 보기에 멀쩡한 코드도 라이브 서버에선 실행까지 잘 되지만 빌드를 수행하면 갖가지 오류를 뱉어낸다.

<p align="center">
	<i>타입이 정확하지 않아아아아아앙아ㅏㅇㄲㄲㄱㅇㅇ악!! 이딴 "불분명한"거 내 앞에서 치워!!!</i>
</p>

<p align="center">
	<i>이거 타입 선언 안 한 새x끼가 너냐?? ㅋㅋㅋㅋㅋㅋ 컴파일 오류 보고싶지 않으면 처---신 잘 하라고-</i>
</p>

<p align="center">
	<i>아니 이거 "null"일 가능성이 있는뎁쇼?? 아 렌더링 후에 반드시 생성되는 DOM이라 확실히 있는 놈이라구요? 아 DOM 그딴건 모르겠고 암튼 null일 수도 있다고 아ㅋㅋㅋㅋㅋㅋ</i>
</p>

더 환장하는건, 실제론 동작 자체에 문제가 없는 소스다. JavaScript라면 무사통과할 수 있는 매우 정상적인 소스라는 뜻이다.

하지만 작고 소중한 TypeScript는 아무도 막을 수 없어서 조금만 의심스러운 부분이 있다면 바로 찡찡대기 시작한다.

특히 라이브러리의 내부 함수를 쓸 때가 좀 고역이였다. 정확한 타입을 선언해주기 위해서 소스 내부를 까서 어떤 타입의 파라미터를 받는지, 어떤 타입을 반환하는지를 확인해야했다. 물론 이게 TypeScript의 존재 의의다만...

이러한 문제에도 불구하고 TypeScript는 내가 JavaScript에서 불편하다고 느낀 것들을 해소해줬다. 문제는 전혀 다른 불편함을 준다는 점이지만..

그래도 나름 재밌는 개발 경험을 줬지 싶다.

## CSS-in-CSS 적용

어렸을 때, 이런 문구 들어본 적 있을 거다.

<p align="center">
	<i>진료는 의사에게, 약은 약사에게</i>
</p>

의약분업을 위한 캐치프레이즈다. 내 블로그에는 통용되지 않는 말이기도 하다.

이전까지의 내 블로그는 CSS-in-JS가 적용되어 있었다. 위에서도 언급했듯이, 내 블로그의 CSS는 전적으로 Material-UI에 의존하고 있었다. 이로 인해 의존할 수 있는 래퍼런스 또한 많지 않았고, 불행히도 Material-UI는 CSS-in-JS 방식의 래퍼런스를 제공한 탓에 지금까지 이런 방식을 적용했었다.

> **CSS-in-JS?** **CSS-in-CSS??**  
> `CSS-in-JS`: JavaScript에서 CSS 담당  
> `CSS-in-CSS`: CSS에서 CSS 담당

몰론 장점도 있었다. CSS-in-JS의 가장 큰 장점은 CSS를 JavaScript에서 관리하므로 CSS의 동적 생성이 쉽다. 더군다나 내 블로그는 다크, 라이트 모드를 토글할 수 있기 때문에 이러한 장점은 더더욱 강력하게 다가왔다.

하지만 위에서도 언급했듯이, 렌더링 및 성능 문제가 가장 큰 이슈로 대두됐고, 이 중 스타일링 구문이 가장 의심이 됐다.

모든 컴포넌트 마다 JavaScript에서 스타일링 구문을 생성해야했고, 게시글 같은 경우 스타일링 요소가 많아 JSX 코드보다도 스타일링 코드가 훨씬 더 길어지는 주객전도가 일어나기도 했다.

더군다나 CSS-in-JS에서 일어나는 치명적인 문제가 있는데, CSS가 적용되기 전인 날 것의 HTML이 잠깐 보이는 현상이다. 이러한 현상을 <span class="priamry">FOUC</span>(Flash of Unstyled Content)라고 부른다.

NextJS에선 emotion.js를 적극적으로 차용하도록 유도하여 이러한 문제를 줄인다고 하는데.. 특별한 이유가 없다면 CSS는 CSS가 담당하는 게 맞다고 생각하여, CSS-in-CSS를 차용하기로 했다.

## SCSS 적용

위에서 언급한 CSS-in-CSS를 위해, 처음엔 CSS를 사용하고자 했다. 하지만 사소한 문제가 하나 있었는데, 기존 소스와의 호환성을 위해선 CSS만으로는 안 된다.

-- 사진

기존의 CSS-in-JS 소스는 이와 같다. Material-UI의 `makeStyles`를 활용한 것으로, 구조를 보면 알겠지만 일반적인 CSS와는 좀 다르다.

``` CSS
.alpha {
	color: red;
}

.alpha .beta {
	background: black;
}
```

``` SCSS
.alpha {
	color: red;

	.beta {
		background: black;
	}
}
```

각각 동일한 동작을 CSS와 SCSS로 표현했다. 보다시피, `makeStyles`와 SCSS의 표기가 매우 흡사함을 알 수 있다. 즉, 구버전의 스타일링 시스템와 호환성을 최대한 높이기 위해선 SCSS 내지는 SASS와 같은 스타일 전처리기가 반드시 필요했다.

그 중 내가 차용한 건 SCSS. SASS는 기존의 CSS와는 살짝 다른 문법을 가지고 있다는 점이 거슬렸다. SCSS는 단순한 스타일링 이외에도 `@mixin`, `@for`나 변수 선언과 같이 좀 더 프로그래밍적인 요소가 강해 더욱 간편한 스타일링 개발 경험을 제공했다.

일장일단이 있던 TypeScript와 달리, 앞으로도 계속 쓰고 싶을 정도로 마음에 들었다.

## marked.js 차용

내가 제대로 알아보질 않아서 그런지 모르겠으나, 기존에 썼던 `unified.js`, `remark`, `rehype` 계열 플러그인의 경우 사용자가 커스터마이징할 여력이 없었던 걸로 기억한다. 때문에 이와 연관된 수 많은 플러그인을 설치해야했다.

더 골때리는건, 적용된 결과물을 커스텀할 명확한 방법을 제공해주지 않았다. 즉, 주는 대로 쓰라는 말인데.. 여러모로 달갑지 않았다.

-- 사진

특히 코드 블록의 경우, 복사 버튼이나 언어 표시 등 다채로운 기능을 추가하고 싶었으나, 그럴 수 없어 난감했다. 굳이 거창한 플러그인이 아니더라도, 변환된 HTML 구문만 던져주면 wrapper라도 하나 만들어서 감싸줄텐데, 그런 것도 없으니 여의치 않았다. 물론 전체 HTML은 갖고 있었다만, 이걸 일일히 파싱해서 추출한다는 것도 다소 무식하기도 하고.

그렇게 찾은 차선책이 `marked.js`다. 이유는 단 한 가지로, 사용자가 결과물을 기본적인 구문 혹은 직접 커스텀한 구문별로 자유로운 커스터마이징이 가능했기 때문.

그래도 Prism.js와 LaTeX를 적용하는 건 녹록치 않았었다. 특히 LaTeX는 완벽히 적용하는데 3일 정도는 걸리지 않았나 싶다. LaTeX의 경우 `$`로 감싼 구문에 적용되는데, 마크다운이 기본적으로 `$`에 뭔가 있는 게 아니기 땨문에 해당 문자열 토큰을 구문별로 감지할 수 있는 로직을 작성해야했다.

그래도 결론적으론 커스터마이징이 훨씬 쉬워서, 이런 것들도 만들 수 있었다.

-- 사진

