---
title: "[백준 / JAVA] 백준 알고리즘 1020번 디지털 카운터"
excerpt: "지민이는 매 초마다 수가 증가하는 N자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. 10^N-1에 이르면 다시 0부터 시작한다. 각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다. 모든 인접한 두 개의 선분은 +로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다. 현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오. 1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 N자리를 채워야 하므로, N자리보다 작을 때는 앞에 0이 있을 수도 있다."
coverImage: "https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png"
date: "2021-07-10T01:52:27"
type: "posts"
category: "알고리즘"
tag: [ "백준", "알고리즘", "JAVA(자바)", "Dynamic Programming(동적 프로그래밍)", "PLATINUM", "PLATINUM II" ]
group: "백준 알고리즘"
comment: true
publish: false
---

# 디지털 카운터

![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)

🔗 [전체 1020번 문제](https://www.acmicpc.net/problem/1020)

## 조건

| 시간제한 | 메모리 제한 |
| :------: | :---------: |
|   2초    |    128MB    |

## 문제

지민이는 매 초마다 수가 증가하는 $N$자리의 디지털 카운터를 가지고 있다. 카운터에 나오는 수는 순환된다. $10^{N - 1}$에 이르면 다시 0부터 시작한다.

각 숫자는 다음과 같은 7개의 선분으로 이루어져 있다.

```
    +   +---+   +---+   +   +   +---+
    |       |       |   |   |   |
    +   +---+   +---+   +---+   +---+
    |   |           |       |       |
    +   +---+   +---+       +   +---+

+---+   +---+   +---+   +---+   +---+
|           |   |   |   |   |   |   |
+---+       +   +---+   +---+   +   +
|   |       |   |   |       |   |   |
+---+       +   +---+       +   +---+
```

모든 인접한 두 개의 선분은 $+$로 이어져 있다. 예를 들어, 1은 두 개의 선분, 9는 다섯 개의 선분으로 이루어져 있다.

현재 카운터에 나와있는 숫자가 주어진다. 그럴 때, 현재 나와있는 숫자의 선분의 개수와 같은 숫자는 최소 몇 초가 지나야 나오는지 구하는 프로그램을 작성하시오.

1, 2, ..., 9, 그리고 0은 모두 2, 5, 5, 4, 5, 6, 3, 7, 5, 6개의 선분으로 이루어져 있고, 모든 수는 $N$자리를 채워야 하므로, $N$자리보다 작을 때는 앞에 0이 있을 수도 있다.

## 입력

첫째 줄에 현재 카운터에 나와있는 수가 주어진다. $N$은 그 수의 길이와 같다. (수가 0으로 시작할 수도 있음) 그리고, $N$은 15보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 최소 몇 초가 지나야 현재 카운터에 나와 있는 수와 선분의 개수가 같아지는지 출력한다.

## 케이스

### 예제 1

+ 입력

``` tc
007
```

+ 출력

``` tc
11
```

# 풀이

## 문제 이해하기

문제 이해도는 그리 높지 않다. <span class="green-A400">디지털 계산기</span>를 생각해보자.

<p align="center">
	<img src="https://user-images.githubusercontent.com/50317129/124596989-df266800-de9d-11eb-963c-2dea1d25f9b3.png" width="600px" />
</p>

숫자를 표현하는데 여러 개의 선분이 필요하며, 문제의 기호보다 위 그림을 보면 쉽게 이해할 수 있을 것이다. 각 숫자를 표현하는데 필요한 숫자를 표로 정리하면 아래와 같다.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   6   |   2   |   5   |   5   |   4   |   5   |   6   |   3   |   7   |   5   |

### 특징 1

임의의 숫자 02를 표현하는데 필요한 선분의 갯수는 각각 6개와 5개로, 11개의 선분이 필요하다.

숫자는 1초마다 바뀌며, 선분의 합이 11개가 되는 숫자가 몇 초 뒤에 나오는지를 계산하면 된다. 선분의 합이 11개인 가장 가까운 수는 03으로, 1초가 걸린다.

만약 정해진 자릿수의 최대를 넘어가면 0부터 다시 돌아와 카운팅한다. 즉, 02의 경우 두 자리이므로, 99를 넘어서면 다시 00으로 되돌아간다.

### 특징 2

이번엔 임의의 숫자 98의 케이스를 생각해보자. 주어진 숫자가 두 자리이므로, $N = 2$임을 알 수 있다. 98을 표현하는데 필요한 선분의 갯수는 각각 7과 5로, 12개의 선분이 필요하다.

99 역시 총 10개의 선분으로 이루어지므로 답이 되지 못하며, 두 자리 수의 최대값은 99이므로 00으로 넘어가서 값을 찾는다. <span class="primary">오버플로우(Overflow)</span>의 개념과 동일하다.

0은 6개의 선분으로 이루어져 있으므로, 00을 표현하는데 필요한 선분의 갯수는 12개다. 즉, 답은 2초가 된다.

이렇게 정해진 자릿수를 초과할 경우 또한 계산해야한다.

## 다이나믹 프로그래밍 적용하기

문제의 요구사항도 직관적이고, 특징 또한 그리 복잡하지 않다. 순수히 문제에서 요구하는 로직 자체가 어렵다.

숫자의 자릿수가 최대 15자리(100조)에 육박하므로, 이렇게 많은 양의 데이터를 빠르게 처리하는데는 <span class="primary">다이나믹 프로그래밍</span>이 적절할 것이다.

또한 `int`는 약 21억까지만 다룰 수 있으므로, `long` 데이터를 써야함을 짐작할 수 있다.

<br />
<br />

그 어떤 고려사항 없이 무식하게 접근한다면 그리 어렵지 않을 것이다. 숫자를 하나하나 분리해서 선분의 갯수를 구하여 합한 다음, 현재 숫자부터 1씩 증가시키며 위 계산을 반복하면 될 것이다. 물론 그렇게 쉬웠다면 내가 일주일 넘게 고민하지도 않았겠지만.

<span class="primary">다이나믹 프로그래밍</span>은 이분 매칭과 같은 특정한 패턴이 있는게 아닌 개념에 가까워서, 이를 적절히 적용할 수 있는 접근 방식<span class="grey-400">(점화식 등)</span>을 도출해야한다.

### 원리 이해하기

이 알고리즘의 핵심은 <span class="red-A400">선분의 합</span>이다. 하나의 숫자를 표시하는데 필요한 선분의 수는 2 ~ 7 사이의 값을 가진다. 동일한 선분의 갯수를 가지는 숫자가 있으므로 일부 겹친다.

만약 하나의 숫자를 통해 만들 수 있는 선분의 합을 나열하고, 이 합을 가질 수 있는 숫자들 중 가장 작은 수를 표시하면 아래와 같다.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   -   |   -   |   1   |   7   |   4   |   2   |   0   |   8   |

예를 들어, 선분의 갯수가 5인 숫자는 [ 2, 3, 5, 9 ]로 4개가 존재한다. 그 중 가장 작은 수는 4이므로 위 표의 5에는 2가 매칭된다.

위 표는 한 자릿수에서 나올 수 있는 경우의 수다. 만약 두 자릿수를 기준으로 표를 도식하면 아래와 같다. 한 자릿수에서의 최소값이 2, 최대값이 7이므로, 두 자릿수에서는 4 ~ 14의 범위를 가짐을 유추할 수 있다.

|   0   |   ~   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |  13   |  14   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   -   |   ~   |  11   |  17   |  14   |  12   |  01   |  07   |  04   |  02   |  00   |  08   |  88   |

위처럼 나타낼 수 있다. 두 자릿수에서 선분의 합이 11인 수는 02가 가장 작음을 바로 찾을 수 있다.

이러한 원리를 통해 자릿수를 하나하나 넓혀가며 동일한 선분을 가지는 값을 찾을 수 있다. 예를 들어, **0598**와 동일한 선분의 수를 갖는 가장 가까운 수를 찾아보자. **0598**의 선분합은 6 + 5 + 5 + 7 = 23다. 즉, 선분의 합이 22인 숫자를 찾으면 된다.

1. 1의 자리 비교하기

1의 자리를 비우면 **059_**와 같이 표기할 수 있다. 8의 선분값은 7이므로 **_**에 0부터 9까지 순차적으로 대입하여 선분값이 7이 되는 수를 찾는다. 단, 원래의 값인 8은 탐색 대상에서 제외한다.

선분의 합이 7이 되는 한 자릿수는 8 이외엔 없으므로, 1의 자리에선 동일한 선분합을 갖는 숫자가 자신 이외에 없다.

2. 10의 자리 비교하기

10의 자리를 비우면 **05_?**와 같이 표기할 수 있다. **_**는 0부터 9까지 대입할 자리이며, **?**은 해당 자리에서 나올 수 있는 선분의 합을 가지는 가장 작은 수가 대입된다.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   -   |   -   |   1   |   7   |   4   |   2   |   0   |   8   |

즉, 1의 자리에서 ?는 위 표에 해당하는 0, 1, 2, 4, 7, 8이 올 수 있으며, 그 밖의 숫자는 대입될 수 없다.

**_**와 **?**에 값을 각각 대입해봄으로써 8과 9의 선분합인 12를 가지는 수를 찾는다.

3. 100의 자리 비교하기

100의 자리를 비우면 **0_??**와 같이 표기할 수 있다.

**_**와 **?**에 값을 각각 대입해봄으로써 8과 9의 선분합인 12를 가지는 수를 찾는다.

### DP배열 만들기





이와 같이, 각 자릿수 별로 나올 수 있는 선분의 합을 가지는 숫자의 최소값을 식으로 도출한다면 <span class="primary">다이나믹 프로그래밍</span>을 적용하여 2차원 배열 `dp[i][j]`로 정의할 수 있다.

* $i$: 자릿수 $(i = 1, 2, \, \, \, \dotsm \, \, \, , 14, 15)$
* $j$: 선분의 합

만약 $dp[3][6]$을 구할 경우, 세 자릿수의 선분 합이 6인 숫자의 최소값이므로 111(2 + 2 + 2)가 된다. 이렇게 적절한 값이 나올 수 있도록 배열 `dp`의 표현식을 도출해야한다.

`dp`의 범위는 한 자릿수에선 2 ~ 7, 두 자릿수에선 4 ~ 14와 같다. 알고리즘에서의 자릿수는 $N$이므로, `dp`의 크기를 식으로 표현하면 아래와 같다.

$$
long[] dp = new long[N + 1][(N * 7) + 1];
$$

값이 크므로 `long` 배열로 선언한다. 배열 `dp`는 0이나 -1과 같이 적절한 값으로 초기화를 진행해준다.

$N = 3$일 경우, 세 자릿수를 가지며, 선분 합의 범위는 6 ~ 21이다. 이를 배열로 초기선언하면 `new long[3][21]`로 표현할 수 있겠지만, 컴퓨터 언어의 특성으로 혼란이 생긴다.

대부분의 컴퓨터 언어는 배열의 시작을 `0`으로 본다. 위와 같이 선언한 매열에서 두 자릿수를 가지며, 선분 합이 10인 값을 호출하려면 `dp[2][10]`이 아니라 `dp[1][9]`를 호출해야한다.

특히 이렇게 복잡한 문제의 경우 변수를 사용하는 과정에서 많은 혼란을 야기할 수 있기 때문에, 가급적 서로 맞춰주는 것이 중요하다. 이를 위해 첫 인덱스인 0을 사용하지 않고 각 선언 크기에 1을 더하여 범위를 증가시킨다음, 시작 인덱스를 1로 사용한다.

즉, 해당 문제에서 $i$와 $j$가 0인 배열은 사용하지 않으며, 어떤 의미도 가지지 않는다.

### DP배열 초기값 지정하기

<span class="primary">다이나믹 프로그래밍</span>은 원래라면 처음부터 다시 계산해야하는 복잡한 과정을 생략하고, 이전에 계산된 내용을 토대로 추가적인 계산을 수행한다.

초기엔 로직에 따른 정석적인 계산을 하지만, 이후 계산값이 쌓임에 따라 이를 활용하여 다음 값을 계산한다. 특히 데이터의 양이 많으면 더더욱 속도에서의 우위를 가져갈 수 있다.

따라서 <span class="primary">다이나믹 프로그래밍</span>은 초기값 설정도 매우 중요하다. 여기서의 초기값은 <span class="teal-A400">한 자리수에서의 선분을 가지는 숫자의 최소값</span>으로 정의할 수 있다.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   -   |   -   |   1   |   7   |   4   |   2   |   0   |   8   |

위 표를 배열 `dp`에 입력하면 된다. 숫자 하나이므로 $i = 1$로 고정이며, $j$는 표의 헤더 부분이다. 값은 표의 각 헤더에 매칭되는 값이다.

``` java
dp[1][2] = 1
dp[1][3] = 7
dp[1][4] = 4
dp[1][5] = 2
dp[1][6] = 0
dp[1][7] = 8 
```

위처럼 선언해주면 된다.

### DP배열 전개하기

지정한 초기값을 토대로 배열 `dp`의 값을 전개한다.

## 전체 소스

``` java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Arrays;

/**
 * 백준 전체 1020 문제 알고리즘 클래스
 *
 * @author RWB
 * @see <a href="https://rwb0104.github.io/posts/2021/07/06/a1020">1020 풀이</a>
 * @since 2021.07.06 11:36:34
 */
public class Main
{
	// 숫자 선분 갯수
	private static final int[] FLAG = { 6, 2, 5, 5, 4, 5, 6, 3, 7, 5 };
	
	// 메모이제이션 배열
	private static long[][] dp;
	
	// 입력 숫자
	private static long number;
	
	// 자리별로 분리된 숫자 배열
	private static int[] numbers;
	
	// 숫자 자릿수
	private static int N;
	
	/**
	 * 메인 함수
	 *
	 * @param args: [String[]] 매개변수
	 *
	 * @throws IOException 데이터 입출력 예외
	 */
	public static void main(String[] args) throws IOException
	{
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
		
		// 입력값
		String input = reader.readLine();
		
		number = Long.parseLong(input);
		
		numbers = Arrays.stream(input.split("")).mapToInt(Integer::parseInt).toArray();
		
		N = numbers.length;
		
		putDP();
		
		long result = solve();
		
		writer.write(String.valueOf(result));
		writer.newLine();
		writer.flush();
		
		writer.close();
		reader.close();
	}
	
	/**
	 * DP 채우기 함수
	 */
	private static void putDP()
	{
		dp = new long[N + 1][(N * 7) + 1];
		
		// 전체 배열을 long의 최대값으로 초기화
		for (long[] arr : dp)
		{
			Arrays.fill(arr, Long.MAX_VALUE);
		}
		
		// 초기값 설정
		for (int i = 0; i < 10; i++)
		{
			dp[1][FLAG[i]] = Math.min(dp[1][FLAG[i]], i);
		}
		
		// 배열 채우기
		for (int i = 2; i < dp.length; i++)
		{
			for (int num = 0; num < 10; num++)
			{
				for (int j = 0; j < dp[i].length; j++)
				{
					// 초기값이 아닌 유효한 값을 가질 경우
					if (dp[i - 1][j] != Long.MAX_VALUE)
					{
						dp[i][j + FLAG[num]] = Math.min(dp[i][j + FLAG[num]], dp[i - 1][j] + (long) Math.pow(10, i - 1) * num);
					}
				}
			}
		}
	}
	
	/**
	 * 알고리즘 동작 함수
	 *
	 * @return [long] 동일한 선분의 갯수를 가지는 숫자가 나오기까지 걸리는 시간
	 */
	private static long solve()
	{
		// 결과
		long result = (long) Math.pow(10, N);
		
		// 1의 자리 숫자만 비교
		for (int num = 0; num < 10; num++)
		{
			// 입력된 숫자의 1의 자리값
			int units = numbers[N - 1];
			
			// 1의 자리 숫자와 num의 선분 갯수가 동일하며, 서로 동일하지 않을 경우
			if (FLAG[units] == FLAG[num] && units != num)
			{
				// num이 1의 자리 숫자보다 클 경우
				if (num > numbers[N - 1])
				{
					result = Math.min(result, num - units);
				}
				
				// num이 1의 자리 숫자보다 작을 경우
				else
				{
					result = Math.min(result, (long) Math.pow(10, N) + num - units);
				}
			}
		}
		
		// 비교할 선분의 갯수 (1의 자리를 위에서 이미 비교했으므로 1의 자리에 해당하는 선분값을 초기값으로 지정)
		int count = FLAG[numbers[N - 1]];
		
		// (10^i)의 자리 숫자부터 하나씩 비교
		for (int i = 2; i < N + 1; i++)
		{
			// (10^i-1)의 자리까지만 표기한 수
			long digit = number % (long) Math.pow(10, i);
			
			// (10^i)의 자릿수 선분 갯수 누적
			count += FLAG[numbers[N - i]];
			
			// (10^i)의 자릿수에 0 ~ 9를 대입하여 비교
			for (int num = 0; num < 10; num++)
			{
				// 비교할 선분의 갯수와 현재 숫자의 선분의 갯수차가 양수일 경우
				if (count - FLAG[num] >= 0)
				{
					// (10^i-1)의 자릿수에 현재 숫자를 곱한 수
					long pows = (long) Math.pow(10, i - 1) * num;
					
					// i-1 자리에서 선분의 합이 (count - FLAG[num])이 되는 가장 작은 수
					long target = dp[i - 1][count - FLAG[num]];
					
					// pows와 target의 합이 digit과 다르며, 유효한 값을 가지는 메모이제이션 배열일 경우
					if (digit != pows + target && target != Long.MAX_VALUE)
					{
						long val = pows + target - digit;
						
						// 계산한 값이 음수일 경우
						if (val <= 0)
						{
							// 10^N 자리를 넘어가므로 한 주기를 돌아 다시 카운팅해야한다.
							val += (long) Math.pow(10, N);
						}
						
						result = Math.min(result, val);
					}
				}
			}
		}
		
		return result;
	}
}
```


## 분류

* 다이나믹 프로그래밍