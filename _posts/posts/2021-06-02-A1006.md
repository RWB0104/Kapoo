---
title: "[JAVA] 백준 알고리즘 1006번 습격자 초라기"
excerpt: "서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft(Association of Construction Mananger Craft)가 발매되었다. 이 게임은 지금까지 나온 게임들과는 다르게 ACM Craft는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다."
coverImage: "https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png"
date: "2021-06-02T01:27:56"
type: "posts"
category: "알고리즘"
tag: [ "백준", "알고리즘", "JAVA(자바)", "DP(동적 계획법)", "PLATINUM", "PLATINUM III" ]
group: "백준 알고리즘"
comment: true
publish: true
---

## Table of Contents

# 습격자 초라기

![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)

🔗 [전체 1006번 문제](https://www.acmicpc.net/problem/1006)

# 조건

| 시간제한 | 메모리 제한 |
| :------: | :---------: |
|   2초    |    512MB    |

## 문제

초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)

<p align="center">
	<img src="https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg" width="400px" />
</p>

초라기는 각각 `W`명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.

1. 한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.
2. 특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.
3. 한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 `W` 보다 작거나 같아야 한다.

이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.

## 입력

첫째 줄에 테스트 케이스의 개수 `T`가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.

첫째 줄에는 (구역의 개수)/2 값 `N`과 특수 소대원의 수 `W`가 주어진다. (`1 ≤ N ≤ 10000`, `1 ≤ W ≤ 10000`).

둘째 줄에는 1 ~ N번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 N + 1 ~ 2N번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ W)

## 출력

각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.

## 케이스

### 예제 1

+ 입력

	1  
	8 100  
	70 60 55 43 57 60 44 50  
	58 40 47 90 45 52 80 40

+ 출력

	11

## 힌트

하나의 특수 소대로 인접한 두 영역을 커버할 수 있는 배치는 (2,10), (9,16), (4,5), (7,8), (13,14) 이다. 그리고 나머지 6개 구역은 각각 하나의 특수 소대로 커버할 수 있다. 그러므로 최소 11개 특수 소대를 침투시켜야 한다.

# 풀이

백준 알고리즘을 순서대로 푸는 나 같은 초심자들에게 <span class="red-A400">힘의 차이</span>를 느끼게 해주는 문제라고 한다. [solved.ac](https://solved.ac/)에 의하면 문제 등급이 무려 <span class="teal-A400">PLATINUM III</span> 수준. 지금까지 푼 문제 중 가장 높은 등급이 [ACM Craft](/posts/2021/06/01/A1005/) (<span class="amber-A400">GOLD III</span>) 수준임을 감안하면 월등히 높은 수준의 문제. 실제로 풀면서도 혼자서는 도저히 방법이 안 떠오르는데다, 풀이를 봐도 이해가 잘 안 됐다.

해당 문제에 주어지는 <span class="primary">구역</span>은 원형이다. 문제를 쉽게 접근하기 위해선 이 원형을 임의로 잘라 직사각형 형태로 전개해야 한다. 즉, <span class="error">풀 때는 직사각형 형태지만, 실제로는 원형이므로 직사각형의 잘린 양 끝부분까지 염두하여 계산</span>을 해야한다. 난이도를 상승시키는 요인 중 하나.

케이스에 제시된 예제를 기준으로 구역을 사각형으로 도식화하면 아래와 같다.

-- 사진 1 --

위 사진과 같이 8x8 배열로 표현할 수 있다. 여기서 여기서 4번째 행까지 특수소대로 채울 수 있는 최소값 `r[6]`는 어떻게 구할 수 있을까?

역으로 한번 생각해보자. 우리 특수소대는 너무나 유능해서 항상 최소의 팀만으로 목표 구역을 점령한다고 해보자. 작전 보고서엔 아래와 같이 점령한 구역을 표시하며, 이를 <span class="yellow-a500">노란색</span> 영역으로 마킹해서 보여준다.

-- 사진 2 --

즉, <span class="yellow-a500">노란색</span> 영역은 최소의 특수소대팀이 투입된 것임을 보여준다. 우리가 실제로 구현할 알고리즘의 결과물이기도 하다.

문제의 설정 상, 특수소대는 반드시 한 팀이 온전히 투입되어야 하며, 한 팀이 최소로 투입 가능한 인원이다. 그렇다면 위 사진에서 특수소대 한 팀이 커버할 수 있는 영역을 제외해보면 `r[6] - 1`로 표현할 수 있으며, 도식화하면 아래와 같이 세 케이스가 나온다.

-- 사진 3 --

즉, 우리가 저 세 케이스에 대한 특수소대팀의 최소값을 계산할 수 있다면, 결과적으로 4번째 행 전체를 커버하는 특수소대팀의 수를 구할 수 있다. 이미 최소 인원이 나머지 구역을 점령한 상황에서, 투입할 수 있는 최소 인원인 한 팀만 투입할 수 있기 때문.

여러 블로그에서 위 세 그림을 많이 봤을 텐데, 뜬금없이 저런 그림이 등장함에는 이와같은 배경이 있는 것이다.

## a[6] 공식

-- 사진 4 --

첫번째 케이스로 `a[6]`의 최소값 공식을 설계하자.

위에서 했던 방식과 마찬가지로 추론하면 `a[6]`에서 한팀을 뺀 `a[6] - 1`을 구해야 하며, 이는 `e`의 조건에 따라 두 케이스로 나눌 수 있다.

### 한팀이 하나의 구역만 커버할 수 있을 경우

`e[][] + e[][] ≥ W`일 경우, 두 구역을 커버할 수 없으므로 하나의 케이스만 해당한다.

-- 사진 5 --

`a[6] - 1 = c[6]` 이므로 `a[6] = c[6] + 1`

## 한팀이 두개의 구역을 커버할 수 있을 경우

`e[][] + e[][] ≤ W`일 경우, 두가지 경우가 생기므로, 두 결과 중 더 작은 값이 `a[6] - 1`이 된다.

-- 사진 6 --

`a[6] - 1 = b[5]` 이므로 `a[6] = b[5] + 1`

`a[6] - 1 = c[6]` 이므로 `a[6] = c[6] + 1`

따라서 아래의 식으로 정리할 수 있다.

`a[6] = min(b[5] + 1, c[6] + 1)`

이를 수식으로 치환하면

`a[i] = min(b[i-1] + 1, c[i] + 1)`

## b[6] 공식

-- 사진 7 --

`b[6]`의 최소값 공식을 설계하자.

`b[6]`에서 한팀을 뺀 `b[6] - 1`을 구해야 하며, 이는 `e`의 조건에 따라 두 케이스로 나눌 수 있다.

### 한팀이 하나의 구역만 커버할 수 있을 경우

`e[][] + e[][] ≥ W`일 경우, 두 구역을 커버할 수 없으므로 하나의 케이스만 해당한다.

-- 사진 8 --

`b[6] - 1 = c[6]` 이므로 `b[6] = c[6] + 1`

### 한팀이 두개의 구역을 커버할 수 있을 경우

`e[][] + e[][] ≤ W`일 경우, 두가지 경우가 생기므로, 두 결과 중 더 작은 값이 `b[6] - 1`이 된다.

-- 사진 9 --

`b[6] - 1 = a[5]` 이므로 `b[6] = a[5] + 1`

`b[6] - 1 = c[6]` 이므로 `b[6] = c[6] + 1`

따라서 아래의 식으로 정리할 수 있다.

`b[6] = min(a[5] + 1, c[6] + 1)`

이를 수식으로 치환하면

`b[i] = min(a[i-1] + 1, c[i] + 1)`

`a[i]`와 반대되는 격이라 볼 수 있다.

## c[6] 공식

-- 사진 10 --

`c[6]`의 최소값 공식을 설계하자.

`c[6]`에서 한팀을 뺀 `c[6] - 1`을 구해야 하며, 이는 `e`의 조건에 따라 여러 케이스로 나눌 수 있다.

### 한팀이 하나의 구역만 커버할 수 있을 경우

`e[][] + e[][] ≥ W`일 경우, 두 구역을 커버할 수 없으므로 두 개의 케이스로 구성된다.

-- 사진 11 --

`c[6] - 1 = b[5]` 이므로 `c[6] = b[5] + 1`

`c[6] - 1 = a[5]` 이므로 `c[6] = a[5] + 1`

두 케이스 중 최소값이 `c[6]`이므로 아래의 식으로 귀결된다.

`c[6] = min(a[5] + 1, b[5] + 1)`

이를 수식으로 치환하면

`c[i] = min(a[i-1] + 1, b[i-1] + 1)`

### 한팀이 두개의 구역을 커버할 수 있을 경우

위 두 케이스와 더불어 추가로 두개의 케이스가 발생한다. `c`의 경우 직사각형이라는 모양과 인접한 두 구역을 점령할 수 있다는 조건에 시너지가 생겨 케이스가 하나 더 발생한다.

-- 사진 12 --

마지막 사진이 그 케이스다. 

## 전체 소스

``` java

```