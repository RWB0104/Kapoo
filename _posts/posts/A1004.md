---
title: "백준 알고리즘 A1004 어린 왕자"
excerpt: "어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다."
coverImage: "http://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og-1200.png"
date: "2021-04-22 21:42:23"
type: "posts"
category: "알고리즘"
tag: [ "백준", "알고리즘", "JAVA" ]
group: "백준 알고리즘"
comment: true
publish: false
---

# 어린 왕자

![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)

🔗 [전체 1004번 문제](https://www.acmicpc.net/problem/1004)

<br />

## 조건

| 시간제한 | 메모리 제한 |
| :------: | :---------: |
|   2초    |    128MB    |

<br />

## 문제

어린 왕자는 소혹성 B-664에서 자신이 사랑하는 한 송이 장미를 위해 살아간다. 어느 날 장미가 위험에 빠지게 된 것을 알게 된 어린 왕자는, 장미를 구하기 위해 은하수를 따라 긴 여행을 하기 시작했다. 하지만 어린 왕자의 우주선은 그렇게 좋지 않아서 행성계 간의 이동을 최대한 피해서 여행해야 한다. 아래의 그림은 어린 왕자가 펼쳐본 은하수 지도의 일부이다.

<p align="center">
	<img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/201003/dfcmhrjj_113gw6bcng2_b.gif" width="512px" />
</p>

빨간 실선은 어린 왕자가 출발점에서 도착점까지 도달하는데 있어서 필요한 행성계 진입/이탈 횟수를 최소화하는 경로이며, 원은 행성계의 경계를 의미한다. 이러한 경로는 여러 개 존재할 수 있지만 적어도 3번의 행성계 진입/이탈이 필요하다는 것을 알 수 있다.

위와 같은 은하수 지도, 출발점, 도착점이 주어졌을 때 어린 왕자에게 필요한 최소의 행성계 진입/이탈 횟수를 구하는 프로그램을 작성해 보자. (행성계의 경계가 맞닿거나 서로 교차하는 경우는 없다고 가정한다. 또한, 출발점이나 도착점이 행성계 경계에 걸쳐진 경우 역시 입력으로 주어지지 않는다.)

<br />

## 입력

입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에 출발점 (x<sub>1</sub>, y<sub>1</sub>)과 도착점 `(x<sub>2</sub>, y<sub>2</sub>)이 주어진다. 두 번째 줄에는 행성계의 개수 n이 주어지며, 세 번째 줄부터 n줄에 걸쳐 행성계의 중점과 반지름 (c<sub>x</sub>, c<sub>y</sub>, r)이 주어진다. 입력제한은 다음과 같다. (-1000 ≤ x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>, c<sub>x</sub>, c<sub>y</sub> ≤ 1000, 1 ≤ r ≤ 1000, 1 ≤ n ≤ 50)

좌표와 반지름은 모두 정수이다.

<br />

## 출력

각 테스트 케이스에 대해 어린 왕자가 거쳐야 할 최소의 행성계 진입/이탈 횟수를 출력한다.

<br />

## 케이스

+ 입력

	2  
	-5 1 12 1  
	7  
	1 1 8  
	-3 -1 1  
	2 2 2  
	5 5 1  
	-4 5 1  
	12 1 1  
	12 1 2  
	-5 1 5 1  
	1  
	0 0 2

+ 출력

	3  
	0

<br />

## 풀이

1002번째 알고리즘의 내용을 응용하면 쉽게 풀 수 있는 문제인 것 같다. 실제로 별다른 레퍼런스를 찾지도 않고 풀 수 있었으니.  

문제를 풀기 전에 몇 가지 집고 넘아갈 게 있다.  
숫자들 때문에 입력의 한 세트를 착각하기 쉽다.

위 예제를 기준으로 설명하면, 첫 번째 숫자는 세트의 갯수. 본문에서는 `2`이므로, 두 세트를 테스트하므로 결과는 두 줄이 출력된다.  
이후 테스트에 필요한 데이터가 출력된다.

-5 1 12 1 <= x<sub>1</sub>, y<sub>1</sub>, x<sub>2</sub>, y<sub>2</sub>  
7 <= 행성 갯수  
1 1 8 <= c<sub>x1</sub>, c<sub>y1</sub>, r<sub>1</sub>  
-3 -1 1  
2 2 2  
5 5 1  
-4 5 1  
12 1 1  
12 1 2 <= 행성 갯수만큼 출력됨  

또한, 결과는 행성계의 진입/이탈 횟수를 통틀어서 출력하므로 굳이 진입/이탈을 구분하여 저장할 필요는 없다.

문제에서 **출발점에서 도착점까지 가는데 통과해야하는 행성계(이하 원, circle)의 최소**를 목적으로 두기 때문에, 반드시 통과해야하는 원만 계산하면 된다.  
출발/도착점이 임의의 원 안에 포함될 경우 반드시 진입/이탈이 일어난다. 따라서, 출발/도착점을 온전히 포함하는 원의 갯수를 계산하면 진입/이탈의 횟수를 구할 수 있다.  
주의할 점이 있는데, **한 원이 출발/도착점을 모두 포함할 경우 계산에서 제외**시켜야 한다.  
하나의 원이 출발/도착점을 전부 포함할 경우, 원 안에서 이동하기 때문에 진입/이탈이 일어나지 않기 때문.

-그림-

원리는 간단하다. 원점과 점의 거리를 계산한다. 계산한 거리가 원의 반지름보다 짧을 경우, 해당 원은 점을 포함하는 셈이다.  
이를 식으로 정리하면 아래와 같다.

<br />

### 완성....?

``` java
import java.util.Scanner;

/**
 * 백준 전체 1003 문제 알고리즘 클래스
 *
 * @author RWB
 * @since 2021.04.21 Wed 23:29:03
 */
public class Main
{
	static Integer[][] arr = new Integer[41][2];

	/**
	 * 메인 함수
	 *
	 * @param args: [String[]] 매개변수
	 */
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);

		// N = 0일 때, 0이 호출되는 횟수
		arr[0][0] = 1;

		// N = 0일 때, 1이 호출되는 횟수
		arr[0][1] = 0;

		// N = 1일 때, 0이 호출되는 횟수
		arr[1][0] = 0;

		// N = 1일 때, 1이 호출되는 횟수
		arr[1][1] = 1;

		int length = scanner.nextInt();

		for (int i = 0; i < length; i++)
		{
			int n = scanner.nextInt();

			int f0 = fibonacci(n - 1);
			int f1 = fibonacci(n);

			System.out.println(f0 + " " + f1);
		}
	}

	/**
	 * 피보나치 값 반환 함수
	 *
	 * @param n: [int] 인덱스
	 *
	 * @return [int] 피보나치 값
	 */
	private static int fibonacci(int n)
	{
		// 인덱스가 0일 경우
		if (n == 0)
		{
			return 0;
		}

		// 인덱스가 1일 경우
		else if (n == 1)
		{
			return 1;
		}

		// 인덱스가 2 이상일 경우 (연산 가능)
		else
		{
			return fibonacci(n - 1) + fibonacci(n - 2);
		}
	}
}
```

<br />

위 코드는 크게 두 가지 문제가 있는데, 우선 `n = 0, 1`일 때의 처리가 정상적으로 이루어지지 않고 있다.  
`f(1) = f(0) + f(-1)`  
N이 문제되기 이전에 이 코드는 런타임 시간 초과로 실패한다. 왜일까?

위 코드는 **불필요한 연산을 너무 많이 수행한다.** 피보나치 수열의 특성 상 `f(N)`을 계산할 경우, `f(N - 1)`, `f(N - 2)` ... 등과 같이 N 이하의 피보나치 값까지 전부 계산하게 된다.  
다시 말하면, `f(6)`을 연산할 경우 계산 과정에서 자연스레 `f(4)`, `f(2)` 등의 피보나치 값을 구할 수 있다.

위 이론을 알고리즘에 적용하면 아래와 같이 응용할 수 있다.  
N을 총 3번 입력한다고 가정하면 N<sub>1</sub>, N<sub>2</sub>, N<sub>3</sub>으로 구분할 수 있다.

N<sub>2</sub> = 8 -> `f(8)` 부터 `f(0)`까지의 값을 구할 수 있음.  
N<sub>3</sub> = 4 -> `f(4)` 부터 `f(0)`까지의 값을 구할 수 있음.

피보나치 연산값을 저장하면 N<sub>n</sub> > N<sub>n+1</sub>일 경우 굳이 **추가적인 연산을 진행하지 않고 이미 저장된 값을 출력**만 함으로써, 런타임 리소스를 줄일 수 있다.

클래스의 멤버변수로 **Integer 배열을 선언**하여 피보나치 수열값을 저장하고, 알고리즘 연산에 이를 활용하면 될 것 같다.

> int는 Primitive(자료형) 데이터고, Integer는 Wrapper 클래스다. Wrapper 클래스는 null 입력이 가능하다는 특징이 있으므로, Integer 역시 숫자 이외에 null값을 입력할 수 있다.  
Integer 배열의 초기값은 null로 지정되므로, 배열의 값이 null인 인덱스는 아직 피보나치 수열 계산이 이루어지지 않은 인덱스라고 판단할 수 있다.

다행히 문제에서 주어진 `N`의 조건은 `0 <= N <= 40`이므로, 배열의 인덱스는 최대 41을 넘지 않음을 알 수 있다.  
(배열은 0부터 시작하므로 40개가 아닌 0을 포함한 41개임에 유의하자)

이후 피보나치 연산에서 각 과정의 값을 배열에 저장하는 로직을 추가한다.  
배열의 값이 null일 경우, 아직 연산이 진행되지 않았으므로 피보나치 연산을 수행하고 배열에 저장한다.  
반대로, 배열이 특정 숫자값을 가질 경우, 이미 연산이 진행된 인덱스이므로 별도의 연산을 거치지 않고 해당 값을 바로 출력한다.

<br />

## 전체 소스

``` java
package all.a1003;

import java.util.Scanner;

/**
 * 백준 전체 1003 문제 알고리즘 클래스
 *
 * @author RWB
 * @since 2021.04.22 Thu 21:42:23
 */
public class Main
{
	static Integer[] arr = new Integer[41];

	/**
	 * 메인 함수
	 *
	 * @param args: [String[]] 매개변수
	 */
	public static void main(String[] args)
	{
		Scanner scanner = new Scanner(System.in);

		// 피보나치 수열 초기값 (N = 0)
		arr[0] = 0;

		// 피보나치 수열 초기값 (N = 1)
		arr[1] = 1;

		int length = scanner.nextInt();

		for (int i = 0; i < length; i++)
		{
			int n = scanner.nextInt();

			fibonacci(n);

			// n이 0일 경우
			if (n == 0)
			{
				System.out.println("1 0");
			}

			// n이 1일 경우
			else if (n == 1)
			{
				System.out.println("0 1");
			}

			// 초기값이 아닐 경우
			else
			{
				System.out.println(new StringBuffer().append(arr[n - 1]).append(" ").append(arr[n]).toString());
			}
		}

		scanner.close();
	}

	/**
	 * 피보나치 값 반환 함수
	 *
	 * @param n: [int] 인덱스
	 *
	 * @return [int] 피보나치 값
	 */
	private static int fibonacci(int n)
	{
		// 해당 인덱스의 피보나치가 아직 연산되지 않았을 경우
		if (arr[n] == null)
		{
			arr[n] = fibonacci(n - 1) + fibonacci(n - 2);
		}

		return arr[n];
	}
}
```