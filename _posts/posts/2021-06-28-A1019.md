---
title: "[백준 / JAVA] 백준 알고리즘 1019번 책 페이지"
excerpt: "지민이는 전체 페이지의 수가 N인 책이 하나 있다. 첫 페이지는 1페이지이고, 마지막 페이지는 N페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자."
coverImage: "https://user-images.githubusercontent.com/50317129/120028591-d5ece480-c02f-11eb-88f0-e14fc647dd81.png"
date: "2021-06-28T12:28:50"
type: "posts"
category: "알고리즘"
tag: [ "백준", "알고리즘", "JAVA(자바)", "GOLD", "GOLD I" ]
group: "백준 알고리즘"
comment: true
publish: true
---

# Contact

![JAVA](https://shields.io/badge/java-JDK%2014-lightgray?logo=java&style=plastic&logoColor=white&labelColor=orange)

🔗 [전체 1019번 문제](https://www.acmicpc.net/problem/1019)

## 조건

| 시간제한 | 메모리 제한 |
| :------: | :---------: |
|   2초    |    128MB    |

## 문제

지민이는 전체 페이지의 수가 $N$인 책이 하나 있다. 첫 페이지는 1 페이지이고, 마지막 페이지는 $N$페이지이다. 각 숫자가 전체 페이지 번호에서 모두 몇 번 나오는지 구해보자.

## 입력

첫째 줄에 $N$이 주어진다. $N$은 $1,000,000,000$보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 0이 총 몇 번 나오는지, 1이 총 몇 번 나오는지, ..., 9가 총 몇 번 나오는지를 공백으로 구분해 출력한다.

## 케이스

### 예제 1

+ 입력

``` tc
11
```

+ 출력

``` tc
1 4 1 1 1 1 1 1 1 1
```

# 풀이

문제는 명확하고 직관적이다. 1페이지부터 $N$페이지까지 나열할 때, <span class="green-400">숫자가 사용된 수를 각 숫자별로 나타내는 문제</span>.

165라는 숫자를 표기하기 위해선 $[ 1, 5, 6 ]$이 사용된다. 이렇게 <span class="green-400">1부터 해당 숫자까지의 모든 숫자를 표현하기 위해 사용한 숫자의 수를 0부터 오름차순으로 출력</span>하면 된다. 

즉, $N = 5$라고 가정하면, 페이지 배열은 $[ 1, 2, 3, 4, 5 ]$까지 나열된다. 각 숫자가 사용된 수를 표로 나타내면 아래와 같다.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |

1부터 5까지 나열하는데, 각각 숫자 하나씩 사용했으니 위 처럼 표시할 수 있다. 그렇다면 예제의 11은 어떨까?

$[ 1, 2, 3, \dots, 10, 11 ]$까지 나열된다. 

1부터 9까지는 각각 숫자가 하나씩 사용되며, 10은 1과 0이 사용되고, 11은 1이 두 개 사용된다.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |

위의 표만큼 숫자가 사용됐다. 이해를 위해 $N = 13$일 경우를 하나 더 해보자.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |

$12 = [ 1, 2 ]$, $13 = [ 1, 3 ]$이 된다. 1 ~ 13에는 11도 포함되기 때문에, 11의 결과에 12, 13의 값을 각각 더해줘도 상관없다.

|   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |

이 정도면 알고리즘이 원하는 게 무엇인지 이해했으리라 생각한다.

사실 무식하게 접근하면, 그리 어려운 문제는 아니다. 하나하나 반복문 돌려가며 숫자 분해해서 해당하는 숫자의 배열에 집어넣으면 그만이니. 하지만 안타깝게도, 변수 $N$의 최대값은 10억 ~~(다행히 int의 최대값은 넘지 않는다.)~~ 에 육박한다. 그 말인즉는 무식하게 접근하면 안 된다는 의미.

그렇다면 어딘가에 존재하는 규칙성을 발견해서 일반식을 설계해야한다는 뜻인데, 이럴땐 하나하나 나열해보면 알 수 있을 것이다.

|   N   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   1   |   0   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |
|   2   |   0   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |   0   |
|   3   |   0   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |   0   |
|   4   |   0   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |   0   |
|   5   |   0   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |   0   |
|   6   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |   0   |
|   7   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |   0   |
|   8   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   0   |
|   9   |   0   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
|  10   |   1   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
|  11   |   1   |   4   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
|  12   |   1   |   5   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |   1   |
|  13   |   1   |   6   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |   1   |
|  14   |   1   |   7   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |   1   |
|  15   |   1   |   8   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |   1   |
|  16   |   1   |   9   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |   1   |
|  17   |   1   |  10   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |   1   |
|  18   |   1   |  11   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   1   |
|  19   |   1   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |
|  20   |   2   |  12   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |
|  21   |   2   |  13   |   4   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |
|  22   |   2   |  13   |   6   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |
|  23   |   2   |  13   |   7   |   3   |   2   |   2   |   2   |   2   |   2   |   2   |

규칙성을 찾아보기 위해 20 받고 살짝 더 얹어서 사용된 숫자를 나열해보았다. 어떤 패턴이 보이는 것 같긴 하다.

1. 0은 10의 배수마다 1씩 증가한다.
2. 각 1의 자리마다 해당하는 숫자가 1씩 증가하며, 값은 10의 자릿수 + 1이다.
3. 10의 자릿수는 해당하는 숫자를 1씩 증가시킨다.

그냥 쳐다보면 규칙성을 찾기 좀 어려울 수 있다. 해답은 $n0 ~ m9$ 구간에 있다. 예를 들어, $10 ~ 29$까지 나열해보자

<table>
	<tbody>
		<tr>
			<td>10</td>
			<td>11</td>
			<td>12</td>
			<td>13</td>
			<td>14</td>
			<td>15</td>
			<td>16</td>
			<td>17</td>
			<td>18</td>
			<td>19</td>
		</tr>
		<tr>
			<td>20</td>
			<td>21</td>
			<td>22</td>
			<td>23</td>
			<td>24</td>
			<td>25</td>
			<td>26</td>
			<td>27</td>
			<td>28</td>
			<td>29</td>
		</tr>
	</tbody>
</table>

1부터 시작하는 것이 아니라, 임의의 구간 $A ~ B$를 기준으로 알고리즘을 계산한다고 가정해보자. 위 표와 같이 10페이지를 시작으로 29까지 사용된 숫자를 표시해보자.

위 표의 숫자들을 잘 보면, 1의 자리 숫자는 각각 하나씩 사용하는 것을 확인할 수 있다.

<table>
	<tbody>
		<tr>
			<td>1<span class="red-A400"></span>0</td>
			<td>1<span class="red-A400"></span>1</td>
			<td>1<span class="red-A400"></span>2</td>
			<td>1<span class="red-A400"></span>3</td>
			<td>1<span class="red-A400"></span>4</td>
			<td>1<span class="red-A400"></span>5</td>
			<td>1<span class="red-A400"></span>6</td>
			<td>1<span class="red-A400"></span>7</td>
			<td>1<span class="red-A400"></span>8</td>
			<td>1<span class="red-A400"></span>9</td>
		</tr>
		<tr>
			<td>2<span class="red-A400"></span>0</td>
			<td>2<span class="red-A400"></span>1</td>
			<td>2<span class="red-A400"></span>2</td>
			<td>2<span class="red-A400"></span>3</td>
			<td>2<span class="red-A400"></span>4</td>
			<td>2<span class="red-A400"></span>5</td>
			<td>2<span class="red-A400"></span>6</td>
			<td>2<span class="red-A400"></span>7</td>
			<td>2<span class="red-A400"></span>8</td>
			<td>2<span class="red-A400"></span>9</td>
		</tr>
	</tbody>
</table>

즉 1의 자리를 기준으로 각 숫자가 2개씩 사용되는 것을 확인할 수 있다.

10의 자리는 1이 10개, 2가 10개 사용됐다.

|    N    |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |
| :-----: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 10 ~ 29 |   2   |  12   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |
| 10 ~ 39 |   3   |  13   |  13   |  13   |   3   |   3   |   3   |   3   |   3   |   3   |
| 20 ~ 39 |   2   |  12   |  12   |   2   |   2   |   2   |   2   |   2   |   2   |   2   |

이제 좀 규칙성이 눈에 띄기 시작한다. 구간이 $n0 ~ m9$ 형식일 경우, 1의 자리를 기준으로 한 일반식은 아래와 같다.

$$
int(M \div 10) - int(N \div 10) + 1
$$

$$
29 \div 10 - 10 \div 10 + 1 = 2 - 1 + 1 = 2
$$

위와 같은 이유로 0 ~ 9까지 각각 $int(M \div 10) - int(N \div 10) + 1$ 만큼 사용한다.

10의 자리의 경우 각 페이지 수에서 자릿수인 10을 나눠 구한다.

$$

$$

## 전체 소스

``` java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;

/**
 * 테스트 메인 클래스
 *
 * @author RWB
 * @see <a href="https://rwb0104.github.io/posts/2021/06/28/A1019/">1019 풀이</a>
 * @since 2021.06.28 Mon 12:28:50
 */
public class Main
{
	// 숫자 카운트 배열
	private static final int[] counter = new int[10];
	
	/**
	 * 메인 함수
	 *
	 * @param args: [String[]] 매개변수
	 *
	 * @throws IOException 데이터 입출력 예외
	 */
	public static void main(String[] args) throws IOException
	{
		BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));
		
		// 마지막 페이지
		int N = Integer.parseInt(reader.readLine());
		
		solve(N);
		
		StringBuilder builder = new StringBuilder();
		
		for (int item : counter)
		{
			builder.append(item).append(" ");
		}
		
		writer.write(builder.toString().trim());
		writer.newLine();
		writer.flush();
		
		reader.close();
		writer.close();
	}
	
	/**
	 * 알고리즘 동작 함수
	 *
	 * @param num: [int] 마지막 페이지
	 */
	private static void solve(int num)
	{
		// 시작 페이지
		int start = 1;
		
		// 자릿수
		int digit = 1;
		
		while (start <= num)
		{
			// 1의 자리가 9가 될 때까지 마지막 페이지를 1씩 감소함
			while (num % 10 != 9 && start <= num)
			{
				// 감소한 페이지 별도 카운팅
				count(num, digit);
				
				num--;
			}
			
			// 마지막 페이지가 시작 페이지보다 작을 경우
			if (num < start)
			{
				// 이를 처리하지 않으면 num < 9일 경우 무한루프를 탐
				break;
			}
			
			// 1의 자리가 0이 될 때까지 시작 페이지를 1씩 증가함
			while (start % 10 != 0 && start <= num)
			{
				// 증가한 페이지 별도 카운팅
				count(start, digit);
				
				start++;
			}
			
			start /= 10;
			num /= 10;
			
			for (int i = 0; i < 10; i++)
			{
				counter[i] += (num - start + 1) * digit;
			}
			
			// 자릿수 증가
			digit *= 10;
		}
	}
	
	/**
	 * 카운트 함수
	 *
	 * @param num: [int] 대상 숫자
	 * @param digit: [int] 자릿수
	 */
	private static void count(int num, int digit)
	{
		while (num > 0)
		{
			counter[num % 10] += digit;
			num /= 10;
		}
	}
}
```

## 분류

* 수학